
R version 4.4.3 (2025-02-28 ucrt) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "LassoHiDFastGibbs"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> base::assign(".ExTimings", "LassoHiDFastGibbs-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('LassoHiDFastGibbs')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("blasso_gibbs_2block_bl")
> ### * blasso_gibbs_2block_bl
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: blasso_gibbs_2block_bl
> ### Title: Bayesian lasso Gibbs sampler: 2-block (beta–lambda2) variant
> ### Aliases: blasso_gibbs_2block_bl
> 
> ### ** Examples
> 
> set.seed(1)
> n <- 30; p <- 6
> X <- matrix(rnorm(n * p), n, p)
> y <- rnorm(n)
> out <- blasso_gibbs_2block_bl(
+   vy = y, mX = X,
+   a = 1, b = 1, u = 1, v = 1,
+   nsamples = 200,
+   lambda_init = 1, sigma2_init = 1,
+   verbose = 0
+ )
> str(out)
List of 3
 $ mBeta   : num [1:200, 1:6] -0.0841 0.1875 -0.1227 -0.1985 0.0718 ...
 $ vsigma2 : num [1:200, 1] 0.692 0.873 1.099 0.936 0.629 ...
 $ vlambda2: num [1:200, 1] 3.42 1.72 1.73 2.27 4.3 ...
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("blasso_gibbs_2block_bl", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("blasso_gibbs_2block_bs")
> ### * blasso_gibbs_2block_bs
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: blasso_gibbs_2block_bs
> ### Title: Bayesian lasso Gibbs sampler: 2-block (beta–sigma2) variant
> ### Aliases: blasso_gibbs_2block_bs
> 
> ### ** Examples
> 
> set.seed(1)
> n <- 30; p <- 6
> X <- matrix(rnorm(n * p), n, p)
> y <- rnorm(n)
> out <- blasso_gibbs_2block_bs(
+   vy = y, mX = X,
+   a = 1, b = 1, u = 1, v = 1,
+   nsamples = 200,
+   lambda_init = 1, sigma2_init = 1,
+   verbose = 0
+ )
> str(out)
List of 3
 $ mBeta   : num [1:200, 1:6] -0.139 -0.302 0.18 -0.123 -0.15 ...
 $ vsigma2 : num [1:200, 1] 1.16 2.17 0.82 1.14 1.1 ...
 $ vlambda2: num [1:200, 1] 3.18 2.12 1.79 2.89 3.79 ...
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("blasso_gibbs_2block_bs", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("blasso_pcg_lambda2_va")
> ### * blasso_pcg_lambda2_va
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: blasso_pcg_lambda2_va
> ### Title: Bayesian lasso PCG sampler: lambda2 collapsed over local scales
> ### Aliases: blasso_pcg_lambda2_va
> 
> ### ** Examples
> 
> set.seed(1)
> n <- 40; p <- 6
> X <- matrix(rnorm(n * p), n, p)
> beta <- c(1.2, 2, -1, 0.5, 0.75, 2.5)
> y <- X %*% beta + rnorm(n)
> 
> out <- blasso_pcg_lambda2_va(
+   vy = y, mX = X,
+   a = 1, b = 1, u = 1, v = 1,
+   nsamples = 200,
+   lambda_init = 1, sigma2_init = 1,
+   verbose = 0
+ )
> 
> summary(out$vlambda2)
       V1         
 Min.   :0.09001  
 1st Qu.:0.53102  
 Median :0.84597  
 Mean   :0.96631  
 3rd Qu.:1.28039  
 Max.   :2.94603  
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("blasso_pcg_lambda2_va", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("blasso_pcg_sigma2_va")
> ### * blasso_pcg_sigma2_va
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: blasso_pcg_sigma2_va
> ### Title: Bayesian lasso PCG sampler: sigma2 collapsed over local scales
> ### Aliases: blasso_pcg_sigma2_va
> 
> ### ** Examples
> 
> set.seed(1)
> n <- 40; p <- 6
> X <- matrix(rnorm(n * p), n, p)
> beta <- c(1.2, 2, -1, 0.5, 0.75, 2.5)
> y <- X %*% beta + rnorm(n)
> 
> out <- blasso_pcg_sigma2_va(
+   vy = y, mX = X,
+   a = 1, b = 1, u = 1, v = 1,
+   nsamples = 200,
+   lambda_init = 1, sigma2_init = 1,
+   va_init = rep(1, p),
+   verbose = 0
+ )
> 
> summary(out$vsigma2)
       V1        
 Min.   :0.4702  
 1st Qu.:0.9306  
 Median :1.0705  
 Mean   :1.1519  
 3rd Qu.:1.2833  
 Max.   :2.7471  
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("blasso_pcg_sigma2_va", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("normalize")
> ### * normalize
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: normalize
> ### Title: Normalize Response and Covariates
> ### Aliases: normalize
> 
> ### ** Examples
> 
> set.seed(1)
> X <- matrix(rnorm(100 * 10), 100, 10)
> beta <- c(2, -3, rep(0, 8))
> y <- as.vector(X %*% beta + rnorm(100))
> norm_result <- normalize(y, X)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("normalize", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("penalized_nested_Gibbs")
> ### * penalized_nested_Gibbs
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: penalized_nested_Gibbs
> ### Title: Penalized nested Gibbs sampler for Bayesian linear regression
> ### Aliases: penalized_nested_Gibbs
> 
> ### ** Examples
> 
> set.seed(1)
> n <- 50; p <- 10
> X <- matrix(rnorm(n * p), n, p)
> y <- rnorm(n)
> 
> out <- penalized_nested_Gibbs(
+   vy = y, mX = X,
+   penalty_type = "lasso",
+   a = 1, b = 1, u = 1, v = 1,
+   nsamples = 200,
+   lambda_init = 1,
+   va_init = NULL,
+   verbose = 0,
+   lower = 1e-12,
+   upper = 5000,
+   s_beta = 1,
+   s_siglam = 1
+ )
> str(out)
List of 3
 $ mBeta   : num [1:200, 1:10] 0.0436 0.0413 -0.3838 -0.1757 -0.138 ...
 $ vsigma2 : num [1:200, 1] 0.679 0.576 0.48 0.515 0.798 ...
 $ vlambda2: num [1:200, 1] 3.2 2.85 5.36 1.66 4.64 ...
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("penalized_nested_Gibbs", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("penalized_pcg_beta_sigma2")
> ### * penalized_pcg_beta_sigma2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: penalized_pcg_beta_sigma2
> ### Title: Penalized PCG sampler: beta block, lambda2 collapsed over sigma2
> ### Aliases: penalized_pcg_beta_sigma2
> 
> ### ** Examples
> 
> set.seed(1)
> n <- 40; p <- 6
> X <- matrix(rnorm(n * p), n, p)
> beta <- c(1.2, 2, -1, 0.5, 0.75, 2.5)
> y <- X %*% beta + rnorm(n)
> 
> out <- penalized_pcg_beta_sigma2(
+   vy = y, mX = X, penalty_type = "horseshoe",
+   a = 1, b = 1, u = 1, v = 1,
+   nsamples = 200,
+   lambda_init = 1, sigma2_init = 1,
+   verbose = 0
+ )
> 
> summary(out$mBeta)
       V1               V2               V3                V4          
 Min.   :0.8838   Min.   :0.7981   Min.   :-1.6778   Min.   :-0.44074  
 1st Qu.:1.2961   1st Qu.:1.4893   1st Qu.:-1.1312   1st Qu.: 0.02654  
 Median :1.4202   Median :1.6218   Median :-1.0078   Median : 0.16127  
 Mean   :1.4502   Mean   :1.6290   Mean   :-0.9911   Mean   : 0.17863  
 3rd Qu.:1.5877   3rd Qu.:1.7976   3rd Qu.:-0.8460   3rd Qu.: 0.31191  
 Max.   :2.0028   Max.   :2.3496   Max.   :-0.4464   Max.   : 0.76648  
       V5                V6       
 Min.   :-0.1513   Min.   :1.942  
 1st Qu.: 0.2534   1st Qu.:2.374  
 Median : 0.3860   Median :2.494  
 Mean   : 0.3831   Mean   :2.493  
 3rd Qu.: 0.5203   3rd Qu.:2.608  
 Max.   : 0.8181   Max.   :2.939  
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("penalized_pcg_beta_sigma2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("penalized_pcg_lambda2_sigma2")
> ### * penalized_pcg_lambda2_sigma2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: penalized_pcg_lambda2_sigma2
> ### Title: Penalized PCG sampler: lambda2 collapsed over sigma2
> ### Aliases: penalized_pcg_lambda2_sigma2
> 
> ### ** Examples
> 
> set.seed(1)
> n <- 40; p <- 6
> X <- matrix(rnorm(n * p), n, p)
> beta <- c(1.2, 2, -1, 0.5, 0.75, 2.5)
> y <- X %*% beta + rnorm(n)
> out <- penalized_pcg_lambda2_sigma2(
+   vy = y, mX = X, penalty_type = "lasso",
+   a = 1, b = 1, u = 1, v = 1,
+   nsamples = 200, lambda_init = 1, sigma2_init = 1,
+   verbose = 0
+ )
> str(out)
List of 3
 $ mBeta   : num [1:200, 1:6] 1.16 1.38 1.61 0.86 1.81 ...
 $ vsigma2 : num [1:200, 1] 1.39 1.03 1.49 1.57 1.35 ...
 $ vlambda2: num [1:200, 1] 0.814 0.391 0.424 0.826 0.691 ...
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("penalized_pcg_lambda2_sigma2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("penalized_pcg_sigma2_beta")
> ### * penalized_pcg_sigma2_beta
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: penalized_pcg_sigma2_beta
> ### Title: Penalized PCG sampler: sigma2 collapsed over beta
> ### Aliases: penalized_pcg_sigma2_beta
> 
> ### ** Examples
> 
> set.seed(1)
> n <- 40; p <- 6
> X <- matrix(rnorm(n * p), n, p)
> beta <- c(1.2, 2, -1, 0.5, 0.75, 2.5)
> y <- X %*% beta + rnorm(n)
> 
> out <- penalized_pcg_sigma2_beta(
+   vy = y, mX = X, penalty_type = "horseshoe",
+   a = 1, b = 1, u = 1, v = 1,
+   nsamples = 200,
+   lambda_init = 1, sigma2_init = 1,
+   va_init = rep(1, p),
+   verbose = 0
+ )
> 
> summary(out$vsigma2)
       V1        
 Min.   :0.6870  
 1st Qu.:0.9619  
 Median :1.1416  
 Mean   :1.1742  
 3rd Qu.:1.3447  
 Max.   :2.5655  
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("penalized_pcg_sigma2_beta", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("penalized_pcg_sigma2_lambda2")
> ### * penalized_pcg_sigma2_lambda2
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: penalized_pcg_sigma2_lambda2
> ### Title: Penalized PCG sampler: sigma2 collapsed over lambda2
> ### Aliases: penalized_pcg_sigma2_lambda2
> 
> ### ** Examples
> 
> set.seed(1)
> n <- 40; p <- 6
> X <- matrix(rnorm(n * p), n, p)
> beta <- c(1.2, 2, -1, 0.5, 0.75, 2.5)
> y <- X %*% beta + rnorm(n)
> 
> out <- penalized_pcg_sigma2_lambda2(
+   vy = y, mX = X, penalty_type = "lasso",
+   a = 1, b = 1, u = 1, v = 1,
+   nsamples = 200,
+   lambda_init = 1, sigma2_init = 1,
+   va_init = rep(1, p),
+   verbose = 0
+ )
> 
> str(out)
List of 3
 $ mBeta   : num [1:200, 1:6] 1.18 1.52 1.25 1.06 1.52 ...
 $ vsigma2 : num [1:200, 1] 1.089 0.936 1.095 1.218 1.044 ...
 $ vlambda2: num [1:200, 1] 0.255 0.693 0.795 0.323 0.132 ...
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("penalized_pcg_sigma2_lambda2", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.05 0.11 1.34 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
